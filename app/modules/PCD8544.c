// Module for interfacing with PCD8544 by xchip

//#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
#include "platform.h"
#include "auxmods.h"
#include "lrotable.h"

#include "c_types.h"
#include "c_string.h"

#define PULLUP PLATFORM_GPIO_PULLUP
#define FLOAT PLATFORM_GPIO_FLOAT
#define OUTPUT PLATFORM_GPIO_OUTPUT
#define INPUT PLATFORM_GPIO_INPUT
#define INTERRUPT PLATFORM_GPIO_INT
#define HIGH PLATFORM_GPIO_HIGH
#define LOW PLATFORM_GPIO_LOW

// Usage:
//
// pcd.init()
// pcd.clear()
// pcd.locate(0,0)
// pcd.contrast(24)
// pcd.print("hello world")


const unsigned char ASCII [] =
{
 0x00, 0x00, 0x00, 0x00, 0x00 // 20  
,0x00, 0x00, 0x5f, 0x00, 0x00 // 21 !
,0x00, 0x07, 0x00, 0x07, 0x00 // 22 "
,0x14, 0x7f, 0x14, 0x7f, 0x14 // 23 #
,0x24, 0x2a, 0x7f, 0x2a, 0x12 // 24 $
,0x23, 0x13, 0x08, 0x64, 0x62 // 25 %
,0x36, 0x49, 0x55, 0x22, 0x50 // 26 &
,0x00, 0x05, 0x03, 0x00, 0x00 // 27 '
,0x00, 0x1c, 0x22, 0x41, 0x00 // 28 (
,0x00, 0x41, 0x22, 0x1c, 0x00 // 29 )
,0x14, 0x08, 0x3e, 0x08, 0x14 // 2a *
,0x08, 0x08, 0x3e, 0x08, 0x08 // 2b +
,0x00, 0x50, 0x30, 0x00, 0x00 // 2c ,
,0x08, 0x08, 0x08, 0x08, 0x08 // 2d -
,0x00, 0x60, 0x60, 0x00, 0x00 // 2e .
,0x20, 0x10, 0x08, 0x04, 0x02 // 2f /
,0x3e, 0x51, 0x49, 0x45, 0x3e // 30 0
,0x00, 0x42, 0x7f, 0x40, 0x00 // 31 1
,0x42, 0x61, 0x51, 0x49, 0x46 // 32 2
,0x21, 0x41, 0x45, 0x4b, 0x31 // 33 3
,0x18, 0x14, 0x12, 0x7f, 0x10 // 34 4
,0x27, 0x45, 0x45, 0x45, 0x39 // 35 5
,0x3c, 0x4a, 0x49, 0x49, 0x30 // 36 6
,0x01, 0x71, 0x09, 0x05, 0x03 // 37 7
,0x36, 0x49, 0x49, 0x49, 0x36 // 38 8
,0x06, 0x49, 0x49, 0x29, 0x1e // 39 9
,0x00, 0x36, 0x36, 0x00, 0x00 // 3a :
,0x00, 0x56, 0x36, 0x00, 0x00 // 3b ;
,0x08, 0x14, 0x22, 0x41, 0x00 // 3c <
,0x14, 0x14, 0x14, 0x14, 0x14 // 3d =
,0x00, 0x41, 0x22, 0x14, 0x08 // 3e >
,0x02, 0x01, 0x51, 0x09, 0x06 // 3f ?
,0x32, 0x49, 0x79, 0x41, 0x3e // 40 @
,0x7e, 0x11, 0x11, 0x11, 0x7e // 41 A
,0x7f, 0x49, 0x49, 0x49, 0x36 // 42 B
,0x3e, 0x41, 0x41, 0x41, 0x22 // 43 C
,0x7f, 0x41, 0x41, 0x22, 0x1c // 44 D
,0x7f, 0x49, 0x49, 0x49, 0x41 // 45 E
,0x7f, 0x09, 0x09, 0x09, 0x01 // 46 F
,0x3e, 0x41, 0x49, 0x49, 0x7a // 47 G
,0x7f, 0x08, 0x08, 0x08, 0x7f // 48 H
,0x00, 0x41, 0x7f, 0x41, 0x00 // 49 I
,0x20, 0x40, 0x41, 0x3f, 0x01 // 4a J
,0x7f, 0x08, 0x14, 0x22, 0x41 // 4b K
,0x7f, 0x40, 0x40, 0x40, 0x40 // 4c L
,0x7f, 0x02, 0x0c, 0x02, 0x7f // 4d M
,0x7f, 0x04, 0x08, 0x10, 0x7f // 4e N
,0x3e, 0x41, 0x41, 0x41, 0x3e // 4f O
,0x7f, 0x09, 0x09, 0x09, 0x06 // 50 P
,0x3e, 0x41, 0x51, 0x21, 0x5e // 51 Q
,0x7f, 0x09, 0x19, 0x29, 0x46 // 52 R
,0x46, 0x49, 0x49, 0x49, 0x31 // 53 S
,0x01, 0x01, 0x7f, 0x01, 0x01 // 54 T
,0x3f, 0x40, 0x40, 0x40, 0x3f // 55 U
,0x1f, 0x20, 0x40, 0x20, 0x1f // 56 V
,0x3f, 0x40, 0x38, 0x40, 0x3f // 57 W
,0x63, 0x14, 0x08, 0x14, 0x63 // 58 X
,0x07, 0x08, 0x70, 0x08, 0x07 // 59 Y
,0x61, 0x51, 0x49, 0x45, 0x43 // 5a Z
,0x00, 0x7f, 0x41, 0x41, 0x00 // 5b [
,0x02, 0x04, 0x08, 0x10, 0x20 // 5c ¥
,0x00, 0x41, 0x41, 0x7f, 0x00 // 5d ]
,0x04, 0x02, 0x01, 0x02, 0x04 // 5e ^
,0x40, 0x40, 0x40, 0x40, 0x40 // 5f _
,0x00, 0x01, 0x02, 0x04, 0x00 // 60 `
,0x20, 0x54, 0x54, 0x54, 0x78 // 61 a
,0x7f, 0x48, 0x44, 0x44, 0x38 // 62 b
,0x38, 0x44, 0x44, 0x44, 0x20 // 63 c
,0x38, 0x44, 0x44, 0x48, 0x7f // 64 d
,0x38, 0x54, 0x54, 0x54, 0x18 // 65 e
,0x08, 0x7e, 0x09, 0x01, 0x02 // 66 f
,0x0c, 0x52, 0x52, 0x52, 0x3e // 67 g
,0x7f, 0x08, 0x04, 0x04, 0x78 // 68 h
,0x00, 0x44, 0x7d, 0x40, 0x00 // 69 i
,0x20, 0x40, 0x44, 0x3d, 0x00 // 6a j 
,0x7f, 0x10, 0x28, 0x44, 0x00 // 6b k
,0x00, 0x41, 0x7f, 0x40, 0x00 // 6c l
,0x7c, 0x04, 0x18, 0x04, 0x78 // 6d m
,0x7c, 0x08, 0x04, 0x04, 0x78 // 6e n
,0x38, 0x44, 0x44, 0x44, 0x38 // 6f o
,0x7c, 0x14, 0x14, 0x14, 0x08 // 70 p
,0x08, 0x14, 0x14, 0x18, 0x7c // 71 q
,0x7c, 0x08, 0x04, 0x04, 0x08 // 72 r
,0x48, 0x54, 0x54, 0x54, 0x20 // 73 s
,0x04, 0x3f, 0x44, 0x40, 0x20 // 74 t
,0x3c, 0x40, 0x40, 0x20, 0x7c // 75 u
,0x1c, 0x20, 0x40, 0x20, 0x1c // 76 v
,0x3c, 0x40, 0x30, 0x40, 0x3c // 77 w
,0x44, 0x28, 0x10, 0x28, 0x44 // 78 x
,0x0c, 0x50, 0x50, 0x50, 0x3c // 79 y
,0x44, 0x64, 0x54, 0x4c, 0x44 // 7a z
,0x00, 0x08, 0x36, 0x41, 0x00 // 7b {
,0x00, 0x00, 0x7f, 0x00, 0x00 // 7c |
,0x00, 0x41, 0x36, 0x08, 0x00 // 7d }
,0x10, 0x08, 0x08, 0x10, 0x08 // 7e ←
,0x78, 0x46, 0x41, 0x46, 0x78 // 7f →
};


static unsigned char PIN_SCLK = 4;
static unsigned char PIN_SDIN = 3;
static unsigned char PIN_DC = 2;
static unsigned char PIN_SCE = 1;
static unsigned char PIN_RESET = 0; 

#define LCD_D HIGH
#define LCD_C LOW

//serialize data to LCD
static void shiftOut(unsigned char value)
{
  uint8_t i;
  for(i=0;i<8;i++)
  {
     platform_gpio_write(PIN_SDIN, (value&( 1<<(7-i) ))>0?HIGH:LOW );
     platform_gpio_write(PIN_SCLK, HIGH );
     platform_gpio_write(PIN_SCLK, LOW );
  }
}

void lcdWrite(unsigned char dc, unsigned char value)
{
     platform_gpio_write(PIN_DC, dc );
     platform_gpio_write(PIN_SCE, LOW );
     shiftOut(value);
     platform_gpio_write(PIN_SCE, HIGH );
}

// print character
void lcdPrintChar(unsigned char c)
{
    size_t j;
    size_t index = (c - 0x20)*5;
    for (j = 0; j < 5; j++)
    {
      lcdWrite(LCD_D, ASCII[index]);
      index++;
    }
    lcdWrite(LCD_D, 0x00);
}

//set cursor por
void lcdLocate(unsigned char x, unsigned char y)
{
  lcdWrite(LCD_C,64|y);
  lcdWrite(LCD_C,128|x);
}

//clear screen
void lcdClear()
{
  unsigned int i;
  for(i=0;i<84*6;i++)
    lcdWrite(LCD_D,0);
}


//initialize the LCD, call this function before using it
static int lpcd8544_init( lua_State* L )
{
  platform_gpio_mode(PIN_SCE,   OUTPUT, PULLUP);
  platform_gpio_mode(PIN_RESET, OUTPUT, PULLUP);
  platform_gpio_mode(PIN_DC,    OUTPUT, PULLUP);
  platform_gpio_mode(PIN_SDIN,  OUTPUT, PULLUP);
  platform_gpio_mode(PIN_SCLK,  OUTPUT, PULLUP);
    
  platform_gpio_write(PIN_SCE,   LOW);
  platform_gpio_write(PIN_RESET, LOW);
  platform_gpio_write(PIN_RESET, HIGH);
    
  lcdWrite(LCD_C, 0x20);  // H=0 (not extended)
  lcdWrite(LCD_C, 0x0C);  // LCD in normal mode. 0x0d for inverse

  lcdWrite(LCD_C, 0x21);  // H=1 (extended).
  lcdWrite(LCD_C, 0x04);  // Set Temp coefficent. --0x04
  lcdWrite(LCD_C, 0x13);  // LCD bias mode 1:48. --0x13
  lcdWrite(LCD_C, 128+27);  // Set LCD Vop (Contrast). --B1

  lcdWrite(LCD_C, 0x20);  // H=0 (not extended)
  lcdClear();
  lcdLocate(0,0);
  return 0;
}

static int lpcd8544_clear( lua_State* L )
{
  lcdClear();
  lcdLocate(0,0);
}

static int lpcd8544_contrast( lua_State* L )
{
  unsigned char c;
  c = luaL_checkinteger( L, 1 );
  lcdWrite(LCD_C, 0x21);  // H=1 (extended).
  lcdWrite(LCD_C, 128 | c);  // Set LCD Vop (Contrast). --B1
  lcdWrite(LCD_C, 0x20);  // H=0 (not extended)
}

static int lpcd8544_print( lua_State* L )
{
  size_t i, sl;

  luaL_checktype( L, 1, LUA_TSTRING );
  const char *str = luaL_checklstring( L, 1, &sl );
  for (i=0;i<sl;i++)
  {
    lcdPrintChar(str[i]);
  }

  return 0;
}


static int lpcd8544_printbin( lua_State* L )
{
  size_t sl,i;

  luaL_checktype( L, 1, LUA_TSTRING );
  const char *str = luaL_checklstring( L, 1, &sl );
  for (i=0;i<sl;i++)
  {
    lcdWrite(LCD_D, str[i]);
  }

  return 0;
}


// Lua: write( pin, level )
static int lpcd8544_locate( lua_State* L )
{
  unsigned int x;
  unsigned int y;

  x = luaL_checkinteger( L, 1 );
  y = luaL_checkinteger( L, 2 );
  lcdLocate(x,y);

  return 0;
}


// Module function map
#define MIN_OPT_LEVEL 2
#include "lrodefs.h"
const LUA_REG_TYPE pcd8544_map[] = 
{
  { LSTRKEY( "init" ), LFUNCVAL( lpcd8544_init ) },
  { LSTRKEY( "print" ), LFUNCVAL( lpcd8544_print ) },
  { LSTRKEY( "printbin" ), LFUNCVAL( lpcd8544_printbin ) },
  { LSTRKEY( "locate" ), LFUNCVAL( lpcd8544_locate ) },
  { LSTRKEY( "clear" ), LFUNCVAL( lpcd8544_clear ) },
  { LSTRKEY( "contrast" ), LFUNCVAL( lpcd8544_contrast ) },
  { LNILKEY, LNILVAL }
};

LUALIB_API int luaopen_pcd8544( lua_State *L )
{
#if LUA_OPTIMIZE_MEMORY > 0
  return 0;
#else // #if LUA_OPTIMIZE_MEMORY > 0
  luaL_register( L, AUXLIB_PCD8544, pcd8544_map );
  return 1;
#endif
}
